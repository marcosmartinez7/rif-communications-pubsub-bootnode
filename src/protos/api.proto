syntax = "proto3";
package communicationsapi;


service CommunicationsApi {
    //Server side stream, there's no need for a bidirectional stream, it's only needed so
    //The client can be notified of events in their subscriptions

    //Test the connection to the server, both the stream a the server response
    rpc PingChannel (Void) returns (PongResponse);

    //Open a data stream with the server, it can only receive messages
    rpc ConnectToCommunicationsNode(Void) returns (stream Notification);

    //Close the data stream
    rpc EndCommunication(Void) returns (Void);

    //Publish a message in a channel
    rpc Publish (PublishPayload) returns (Void);

    //Subscribe to a channel
    rpc Subscribe (Channel) returns (Void);

    //Unsubscribe to a channel
    rpc Unsubscribe (Channel) returns (Void);

    //Get the subscribers of a participating channel
    rpc GetSubscribers(Channel) returns (Subscribers);

    //Query if a subscriber exists in a participating channel
    rpc HasSubscriber(Subscriber) returns (BooleanResponse);
    
    //Send a message to a peer
    rpc SendMessage(Msg) returns (Void);
}


message Channel {
    string channelId = 1;
}

/*RPC needs a message, so when there are no params to send, this empty message is used*/
message Void {}

message Notification {
    enum NotificationType {
        INVITATION_TO_ROOM = 0;
        INVITATION_TO_ROOM_RESPONSE = 1;
        AUTHENTICATION_REQUEST = 2;
        AUTHENTICATION_RESPONSE = 3;
        NEW_MESSAGE = 4;
        NEW_MESSAGE_RESPONSE = 5;
    }
    NotificationType type = 1;
    string message = 2;
}

message Subscribers {
    repeated string peerId = 2;
}

message Subscriber {
    string peerId = 1;
    Channel channel = 2;
}

message PongResponse {
    bool success = 1;
    string message = 2;
}

message BooleanResponse {
    bool payload = 1;
}

message PublishPayload {
    string topic = 1;
    bytes message = 2;
}

message Msg {
    optional string to = 1;
    bytes data  = 2;
}

